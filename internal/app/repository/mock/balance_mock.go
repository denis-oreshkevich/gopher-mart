package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/denis-oreshkevich/gopher-mart/internal/app/domain/balance.Repository -o ./internal/app/repository/mock/balance_mock.go -n BalanceRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_balance "github.com/denis-oreshkevich/gopher-mart/internal/app/domain/balance"
	"github.com/gojuno/minimock/v3"
)

// BalanceRepositoryMock implements balance.Repository
type BalanceRepositoryMock struct {
	t minimock.Tester

	funcCreateBalance          func(ctx context.Context, userID string) (err error)
	inspectFuncCreateBalance   func(ctx context.Context, userID string)
	afterCreateBalanceCounter  uint64
	beforeCreateBalanceCounter uint64
	CreateBalanceMock          mBalanceRepositoryMockCreateBalance

	funcFindBalanceByUserID          func(ctx context.Context, userID string) (b1 mm_balance.Balance, err error)
	inspectFuncFindBalanceByUserID   func(ctx context.Context, userID string)
	afterFindBalanceByUserIDCounter  uint64
	beforeFindBalanceByUserIDCounter uint64
	FindBalanceByUserIDMock          mBalanceRepositoryMockFindBalanceByUserID

	funcRefillBalanceByUserID          func(ctx context.Context, sum float64, userID string) (err error)
	inspectFuncRefillBalanceByUserID   func(ctx context.Context, sum float64, userID string)
	afterRefillBalanceByUserIDCounter  uint64
	beforeRefillBalanceByUserIDCounter uint64
	RefillBalanceByUserIDMock          mBalanceRepositoryMockRefillBalanceByUserID

	funcWithdrawBalanceByUserID          func(ctx context.Context, sum float64, userID string) (err error)
	inspectFuncWithdrawBalanceByUserID   func(ctx context.Context, sum float64, userID string)
	afterWithdrawBalanceByUserIDCounter  uint64
	beforeWithdrawBalanceByUserIDCounter uint64
	WithdrawBalanceByUserIDMock          mBalanceRepositoryMockWithdrawBalanceByUserID
}

// NewBalanceRepositoryMock returns a mock for balance.Repository
func NewBalanceRepositoryMock(t minimock.Tester) *BalanceRepositoryMock {
	m := &BalanceRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateBalanceMock = mBalanceRepositoryMockCreateBalance{mock: m}
	m.CreateBalanceMock.callArgs = []*BalanceRepositoryMockCreateBalanceParams{}

	m.FindBalanceByUserIDMock = mBalanceRepositoryMockFindBalanceByUserID{mock: m}
	m.FindBalanceByUserIDMock.callArgs = []*BalanceRepositoryMockFindBalanceByUserIDParams{}

	m.RefillBalanceByUserIDMock = mBalanceRepositoryMockRefillBalanceByUserID{mock: m}
	m.RefillBalanceByUserIDMock.callArgs = []*BalanceRepositoryMockRefillBalanceByUserIDParams{}

	m.WithdrawBalanceByUserIDMock = mBalanceRepositoryMockWithdrawBalanceByUserID{mock: m}
	m.WithdrawBalanceByUserIDMock.callArgs = []*BalanceRepositoryMockWithdrawBalanceByUserIDParams{}

	return m
}

type mBalanceRepositoryMockCreateBalance struct {
	mock               *BalanceRepositoryMock
	defaultExpectation *BalanceRepositoryMockCreateBalanceExpectation
	expectations       []*BalanceRepositoryMockCreateBalanceExpectation

	callArgs []*BalanceRepositoryMockCreateBalanceParams
	mutex    sync.RWMutex
}

// BalanceRepositoryMockCreateBalanceExpectation specifies expectation struct of the Repository.CreateBalance
type BalanceRepositoryMockCreateBalanceExpectation struct {
	mock    *BalanceRepositoryMock
	params  *BalanceRepositoryMockCreateBalanceParams
	results *BalanceRepositoryMockCreateBalanceResults
	Counter uint64
}

// BalanceRepositoryMockCreateBalanceParams contains parameters of the Repository.CreateBalance
type BalanceRepositoryMockCreateBalanceParams struct {
	ctx    context.Context
	userID string
}

// BalanceRepositoryMockCreateBalanceResults contains results of the Repository.CreateBalance
type BalanceRepositoryMockCreateBalanceResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateBalance
func (mmCreateBalance *mBalanceRepositoryMockCreateBalance) Expect(ctx context.Context, userID string) *mBalanceRepositoryMockCreateBalance {
	if mmCreateBalance.mock.funcCreateBalance != nil {
		mmCreateBalance.mock.t.Fatalf("BalanceRepositoryMock.CreateBalance mock is already set by Set")
	}

	if mmCreateBalance.defaultExpectation == nil {
		mmCreateBalance.defaultExpectation = &BalanceRepositoryMockCreateBalanceExpectation{}
	}

	mmCreateBalance.defaultExpectation.params = &BalanceRepositoryMockCreateBalanceParams{ctx, userID}
	for _, e := range mmCreateBalance.expectations {
		if minimock.Equal(e.params, mmCreateBalance.defaultExpectation.params) {
			mmCreateBalance.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateBalance.defaultExpectation.params)
		}
	}

	return mmCreateBalance
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateBalance
func (mmCreateBalance *mBalanceRepositoryMockCreateBalance) Inspect(f func(ctx context.Context, userID string)) *mBalanceRepositoryMockCreateBalance {
	if mmCreateBalance.mock.inspectFuncCreateBalance != nil {
		mmCreateBalance.mock.t.Fatalf("Inspect function is already set for BalanceRepositoryMock.CreateBalance")
	}

	mmCreateBalance.mock.inspectFuncCreateBalance = f

	return mmCreateBalance
}

// Return sets up results that will be returned by Repository.CreateBalance
func (mmCreateBalance *mBalanceRepositoryMockCreateBalance) Return(err error) *BalanceRepositoryMock {
	if mmCreateBalance.mock.funcCreateBalance != nil {
		mmCreateBalance.mock.t.Fatalf("BalanceRepositoryMock.CreateBalance mock is already set by Set")
	}

	if mmCreateBalance.defaultExpectation == nil {
		mmCreateBalance.defaultExpectation = &BalanceRepositoryMockCreateBalanceExpectation{mock: mmCreateBalance.mock}
	}
	mmCreateBalance.defaultExpectation.results = &BalanceRepositoryMockCreateBalanceResults{err}
	return mmCreateBalance.mock
}

// Set uses given function f to mock the Repository.CreateBalance method
func (mmCreateBalance *mBalanceRepositoryMockCreateBalance) Set(f func(ctx context.Context, userID string) (err error)) *BalanceRepositoryMock {
	if mmCreateBalance.defaultExpectation != nil {
		mmCreateBalance.mock.t.Fatalf("Default expectation is already set for the Repository.CreateBalance method")
	}

	if len(mmCreateBalance.expectations) > 0 {
		mmCreateBalance.mock.t.Fatalf("Some expectations are already set for the Repository.CreateBalance method")
	}

	mmCreateBalance.mock.funcCreateBalance = f
	return mmCreateBalance.mock
}

// When sets expectation for the Repository.CreateBalance which will trigger the result defined by the following
// Then helper
func (mmCreateBalance *mBalanceRepositoryMockCreateBalance) When(ctx context.Context, userID string) *BalanceRepositoryMockCreateBalanceExpectation {
	if mmCreateBalance.mock.funcCreateBalance != nil {
		mmCreateBalance.mock.t.Fatalf("BalanceRepositoryMock.CreateBalance mock is already set by Set")
	}

	expectation := &BalanceRepositoryMockCreateBalanceExpectation{
		mock:   mmCreateBalance.mock,
		params: &BalanceRepositoryMockCreateBalanceParams{ctx, userID},
	}
	mmCreateBalance.expectations = append(mmCreateBalance.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateBalance return parameters for the expectation previously defined by the When method
func (e *BalanceRepositoryMockCreateBalanceExpectation) Then(err error) *BalanceRepositoryMock {
	e.results = &BalanceRepositoryMockCreateBalanceResults{err}
	return e.mock
}

// CreateBalance implements balance.Repository
func (mmCreateBalance *BalanceRepositoryMock) CreateBalance(ctx context.Context, userID string) (err error) {
	mm_atomic.AddUint64(&mmCreateBalance.beforeCreateBalanceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateBalance.afterCreateBalanceCounter, 1)

	if mmCreateBalance.inspectFuncCreateBalance != nil {
		mmCreateBalance.inspectFuncCreateBalance(ctx, userID)
	}

	mm_params := &BalanceRepositoryMockCreateBalanceParams{ctx, userID}

	// Record call args
	mmCreateBalance.CreateBalanceMock.mutex.Lock()
	mmCreateBalance.CreateBalanceMock.callArgs = append(mmCreateBalance.CreateBalanceMock.callArgs, mm_params)
	mmCreateBalance.CreateBalanceMock.mutex.Unlock()

	for _, e := range mmCreateBalance.CreateBalanceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateBalance.CreateBalanceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateBalance.CreateBalanceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateBalance.CreateBalanceMock.defaultExpectation.params
		mm_got := BalanceRepositoryMockCreateBalanceParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateBalance.t.Errorf("BalanceRepositoryMock.CreateBalance got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateBalance.CreateBalanceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateBalance.t.Fatal("No results are set for the BalanceRepositoryMock.CreateBalance")
		}
		return (*mm_results).err
	}
	if mmCreateBalance.funcCreateBalance != nil {
		return mmCreateBalance.funcCreateBalance(ctx, userID)
	}
	mmCreateBalance.t.Fatalf("Unexpected call to BalanceRepositoryMock.CreateBalance. %v %v", ctx, userID)
	return
}

// CreateBalanceAfterCounter returns a count of finished BalanceRepositoryMock.CreateBalance invocations
func (mmCreateBalance *BalanceRepositoryMock) CreateBalanceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBalance.afterCreateBalanceCounter)
}

// CreateBalanceBeforeCounter returns a count of BalanceRepositoryMock.CreateBalance invocations
func (mmCreateBalance *BalanceRepositoryMock) CreateBalanceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateBalance.beforeCreateBalanceCounter)
}

// Calls returns a list of arguments used in each call to BalanceRepositoryMock.CreateBalance.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateBalance *mBalanceRepositoryMockCreateBalance) Calls() []*BalanceRepositoryMockCreateBalanceParams {
	mmCreateBalance.mutex.RLock()

	argCopy := make([]*BalanceRepositoryMockCreateBalanceParams, len(mmCreateBalance.callArgs))
	copy(argCopy, mmCreateBalance.callArgs)

	mmCreateBalance.mutex.RUnlock()

	return argCopy
}

// MinimockCreateBalanceDone returns true if the count of the CreateBalance invocations corresponds
// the number of defined expectations
func (m *BalanceRepositoryMock) MinimockCreateBalanceDone() bool {
	for _, e := range m.CreateBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBalanceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBalanceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBalance != nil && mm_atomic.LoadUint64(&m.afterCreateBalanceCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateBalanceInspect logs each unmet expectation
func (m *BalanceRepositoryMock) MinimockCreateBalanceInspect() {
	for _, e := range m.CreateBalanceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BalanceRepositoryMock.CreateBalance with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateBalanceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateBalanceCounter) < 1 {
		if m.CreateBalanceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BalanceRepositoryMock.CreateBalance")
		} else {
			m.t.Errorf("Expected call to BalanceRepositoryMock.CreateBalance with params: %#v", *m.CreateBalanceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateBalance != nil && mm_atomic.LoadUint64(&m.afterCreateBalanceCounter) < 1 {
		m.t.Error("Expected call to BalanceRepositoryMock.CreateBalance")
	}
}

type mBalanceRepositoryMockFindBalanceByUserID struct {
	mock               *BalanceRepositoryMock
	defaultExpectation *BalanceRepositoryMockFindBalanceByUserIDExpectation
	expectations       []*BalanceRepositoryMockFindBalanceByUserIDExpectation

	callArgs []*BalanceRepositoryMockFindBalanceByUserIDParams
	mutex    sync.RWMutex
}

// BalanceRepositoryMockFindBalanceByUserIDExpectation specifies expectation struct of the Repository.FindBalanceByUserID
type BalanceRepositoryMockFindBalanceByUserIDExpectation struct {
	mock    *BalanceRepositoryMock
	params  *BalanceRepositoryMockFindBalanceByUserIDParams
	results *BalanceRepositoryMockFindBalanceByUserIDResults
	Counter uint64
}

// BalanceRepositoryMockFindBalanceByUserIDParams contains parameters of the Repository.FindBalanceByUserID
type BalanceRepositoryMockFindBalanceByUserIDParams struct {
	ctx    context.Context
	userID string
}

// BalanceRepositoryMockFindBalanceByUserIDResults contains results of the Repository.FindBalanceByUserID
type BalanceRepositoryMockFindBalanceByUserIDResults struct {
	b1  mm_balance.Balance
	err error
}

// Expect sets up expected params for Repository.FindBalanceByUserID
func (mmFindBalanceByUserID *mBalanceRepositoryMockFindBalanceByUserID) Expect(ctx context.Context, userID string) *mBalanceRepositoryMockFindBalanceByUserID {
	if mmFindBalanceByUserID.mock.funcFindBalanceByUserID != nil {
		mmFindBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.FindBalanceByUserID mock is already set by Set")
	}

	if mmFindBalanceByUserID.defaultExpectation == nil {
		mmFindBalanceByUserID.defaultExpectation = &BalanceRepositoryMockFindBalanceByUserIDExpectation{}
	}

	mmFindBalanceByUserID.defaultExpectation.params = &BalanceRepositoryMockFindBalanceByUserIDParams{ctx, userID}
	for _, e := range mmFindBalanceByUserID.expectations {
		if minimock.Equal(e.params, mmFindBalanceByUserID.defaultExpectation.params) {
			mmFindBalanceByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindBalanceByUserID.defaultExpectation.params)
		}
	}

	return mmFindBalanceByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.FindBalanceByUserID
func (mmFindBalanceByUserID *mBalanceRepositoryMockFindBalanceByUserID) Inspect(f func(ctx context.Context, userID string)) *mBalanceRepositoryMockFindBalanceByUserID {
	if mmFindBalanceByUserID.mock.inspectFuncFindBalanceByUserID != nil {
		mmFindBalanceByUserID.mock.t.Fatalf("Inspect function is already set for BalanceRepositoryMock.FindBalanceByUserID")
	}

	mmFindBalanceByUserID.mock.inspectFuncFindBalanceByUserID = f

	return mmFindBalanceByUserID
}

// Return sets up results that will be returned by Repository.FindBalanceByUserID
func (mmFindBalanceByUserID *mBalanceRepositoryMockFindBalanceByUserID) Return(b1 mm_balance.Balance, err error) *BalanceRepositoryMock {
	if mmFindBalanceByUserID.mock.funcFindBalanceByUserID != nil {
		mmFindBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.FindBalanceByUserID mock is already set by Set")
	}

	if mmFindBalanceByUserID.defaultExpectation == nil {
		mmFindBalanceByUserID.defaultExpectation = &BalanceRepositoryMockFindBalanceByUserIDExpectation{mock: mmFindBalanceByUserID.mock}
	}
	mmFindBalanceByUserID.defaultExpectation.results = &BalanceRepositoryMockFindBalanceByUserIDResults{b1, err}
	return mmFindBalanceByUserID.mock
}

// Set uses given function f to mock the Repository.FindBalanceByUserID method
func (mmFindBalanceByUserID *mBalanceRepositoryMockFindBalanceByUserID) Set(f func(ctx context.Context, userID string) (b1 mm_balance.Balance, err error)) *BalanceRepositoryMock {
	if mmFindBalanceByUserID.defaultExpectation != nil {
		mmFindBalanceByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.FindBalanceByUserID method")
	}

	if len(mmFindBalanceByUserID.expectations) > 0 {
		mmFindBalanceByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.FindBalanceByUserID method")
	}

	mmFindBalanceByUserID.mock.funcFindBalanceByUserID = f
	return mmFindBalanceByUserID.mock
}

// When sets expectation for the Repository.FindBalanceByUserID which will trigger the result defined by the following
// Then helper
func (mmFindBalanceByUserID *mBalanceRepositoryMockFindBalanceByUserID) When(ctx context.Context, userID string) *BalanceRepositoryMockFindBalanceByUserIDExpectation {
	if mmFindBalanceByUserID.mock.funcFindBalanceByUserID != nil {
		mmFindBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.FindBalanceByUserID mock is already set by Set")
	}

	expectation := &BalanceRepositoryMockFindBalanceByUserIDExpectation{
		mock:   mmFindBalanceByUserID.mock,
		params: &BalanceRepositoryMockFindBalanceByUserIDParams{ctx, userID},
	}
	mmFindBalanceByUserID.expectations = append(mmFindBalanceByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.FindBalanceByUserID return parameters for the expectation previously defined by the When method
func (e *BalanceRepositoryMockFindBalanceByUserIDExpectation) Then(b1 mm_balance.Balance, err error) *BalanceRepositoryMock {
	e.results = &BalanceRepositoryMockFindBalanceByUserIDResults{b1, err}
	return e.mock
}

// FindBalanceByUserID implements balance.Repository
func (mmFindBalanceByUserID *BalanceRepositoryMock) FindBalanceByUserID(ctx context.Context, userID string) (b1 mm_balance.Balance, err error) {
	mm_atomic.AddUint64(&mmFindBalanceByUserID.beforeFindBalanceByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindBalanceByUserID.afterFindBalanceByUserIDCounter, 1)

	if mmFindBalanceByUserID.inspectFuncFindBalanceByUserID != nil {
		mmFindBalanceByUserID.inspectFuncFindBalanceByUserID(ctx, userID)
	}

	mm_params := &BalanceRepositoryMockFindBalanceByUserIDParams{ctx, userID}

	// Record call args
	mmFindBalanceByUserID.FindBalanceByUserIDMock.mutex.Lock()
	mmFindBalanceByUserID.FindBalanceByUserIDMock.callArgs = append(mmFindBalanceByUserID.FindBalanceByUserIDMock.callArgs, mm_params)
	mmFindBalanceByUserID.FindBalanceByUserIDMock.mutex.Unlock()

	for _, e := range mmFindBalanceByUserID.FindBalanceByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmFindBalanceByUserID.FindBalanceByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindBalanceByUserID.FindBalanceByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindBalanceByUserID.FindBalanceByUserIDMock.defaultExpectation.params
		mm_got := BalanceRepositoryMockFindBalanceByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindBalanceByUserID.t.Errorf("BalanceRepositoryMock.FindBalanceByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindBalanceByUserID.FindBalanceByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindBalanceByUserID.t.Fatal("No results are set for the BalanceRepositoryMock.FindBalanceByUserID")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmFindBalanceByUserID.funcFindBalanceByUserID != nil {
		return mmFindBalanceByUserID.funcFindBalanceByUserID(ctx, userID)
	}
	mmFindBalanceByUserID.t.Fatalf("Unexpected call to BalanceRepositoryMock.FindBalanceByUserID. %v %v", ctx, userID)
	return
}

// FindBalanceByUserIDAfterCounter returns a count of finished BalanceRepositoryMock.FindBalanceByUserID invocations
func (mmFindBalanceByUserID *BalanceRepositoryMock) FindBalanceByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindBalanceByUserID.afterFindBalanceByUserIDCounter)
}

// FindBalanceByUserIDBeforeCounter returns a count of BalanceRepositoryMock.FindBalanceByUserID invocations
func (mmFindBalanceByUserID *BalanceRepositoryMock) FindBalanceByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindBalanceByUserID.beforeFindBalanceByUserIDCounter)
}

// Calls returns a list of arguments used in each call to BalanceRepositoryMock.FindBalanceByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindBalanceByUserID *mBalanceRepositoryMockFindBalanceByUserID) Calls() []*BalanceRepositoryMockFindBalanceByUserIDParams {
	mmFindBalanceByUserID.mutex.RLock()

	argCopy := make([]*BalanceRepositoryMockFindBalanceByUserIDParams, len(mmFindBalanceByUserID.callArgs))
	copy(argCopy, mmFindBalanceByUserID.callArgs)

	mmFindBalanceByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockFindBalanceByUserIDDone returns true if the count of the FindBalanceByUserID invocations corresponds
// the number of defined expectations
func (m *BalanceRepositoryMock) MinimockFindBalanceByUserIDDone() bool {
	for _, e := range m.FindBalanceByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindBalanceByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindBalanceByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindBalanceByUserID != nil && mm_atomic.LoadUint64(&m.afterFindBalanceByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindBalanceByUserIDInspect logs each unmet expectation
func (m *BalanceRepositoryMock) MinimockFindBalanceByUserIDInspect() {
	for _, e := range m.FindBalanceByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BalanceRepositoryMock.FindBalanceByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindBalanceByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindBalanceByUserIDCounter) < 1 {
		if m.FindBalanceByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BalanceRepositoryMock.FindBalanceByUserID")
		} else {
			m.t.Errorf("Expected call to BalanceRepositoryMock.FindBalanceByUserID with params: %#v", *m.FindBalanceByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindBalanceByUserID != nil && mm_atomic.LoadUint64(&m.afterFindBalanceByUserIDCounter) < 1 {
		m.t.Error("Expected call to BalanceRepositoryMock.FindBalanceByUserID")
	}
}

type mBalanceRepositoryMockRefillBalanceByUserID struct {
	mock               *BalanceRepositoryMock
	defaultExpectation *BalanceRepositoryMockRefillBalanceByUserIDExpectation
	expectations       []*BalanceRepositoryMockRefillBalanceByUserIDExpectation

	callArgs []*BalanceRepositoryMockRefillBalanceByUserIDParams
	mutex    sync.RWMutex
}

// BalanceRepositoryMockRefillBalanceByUserIDExpectation specifies expectation struct of the Repository.RefillBalanceByUserID
type BalanceRepositoryMockRefillBalanceByUserIDExpectation struct {
	mock    *BalanceRepositoryMock
	params  *BalanceRepositoryMockRefillBalanceByUserIDParams
	results *BalanceRepositoryMockRefillBalanceByUserIDResults
	Counter uint64
}

// BalanceRepositoryMockRefillBalanceByUserIDParams contains parameters of the Repository.RefillBalanceByUserID
type BalanceRepositoryMockRefillBalanceByUserIDParams struct {
	ctx    context.Context
	sum    float64
	userID string
}

// BalanceRepositoryMockRefillBalanceByUserIDResults contains results of the Repository.RefillBalanceByUserID
type BalanceRepositoryMockRefillBalanceByUserIDResults struct {
	err error
}

// Expect sets up expected params for Repository.RefillBalanceByUserID
func (mmRefillBalanceByUserID *mBalanceRepositoryMockRefillBalanceByUserID) Expect(ctx context.Context, sum float64, userID string) *mBalanceRepositoryMockRefillBalanceByUserID {
	if mmRefillBalanceByUserID.mock.funcRefillBalanceByUserID != nil {
		mmRefillBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.RefillBalanceByUserID mock is already set by Set")
	}

	if mmRefillBalanceByUserID.defaultExpectation == nil {
		mmRefillBalanceByUserID.defaultExpectation = &BalanceRepositoryMockRefillBalanceByUserIDExpectation{}
	}

	mmRefillBalanceByUserID.defaultExpectation.params = &BalanceRepositoryMockRefillBalanceByUserIDParams{ctx, sum, userID}
	for _, e := range mmRefillBalanceByUserID.expectations {
		if minimock.Equal(e.params, mmRefillBalanceByUserID.defaultExpectation.params) {
			mmRefillBalanceByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefillBalanceByUserID.defaultExpectation.params)
		}
	}

	return mmRefillBalanceByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.RefillBalanceByUserID
func (mmRefillBalanceByUserID *mBalanceRepositoryMockRefillBalanceByUserID) Inspect(f func(ctx context.Context, sum float64, userID string)) *mBalanceRepositoryMockRefillBalanceByUserID {
	if mmRefillBalanceByUserID.mock.inspectFuncRefillBalanceByUserID != nil {
		mmRefillBalanceByUserID.mock.t.Fatalf("Inspect function is already set for BalanceRepositoryMock.RefillBalanceByUserID")
	}

	mmRefillBalanceByUserID.mock.inspectFuncRefillBalanceByUserID = f

	return mmRefillBalanceByUserID
}

// Return sets up results that will be returned by Repository.RefillBalanceByUserID
func (mmRefillBalanceByUserID *mBalanceRepositoryMockRefillBalanceByUserID) Return(err error) *BalanceRepositoryMock {
	if mmRefillBalanceByUserID.mock.funcRefillBalanceByUserID != nil {
		mmRefillBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.RefillBalanceByUserID mock is already set by Set")
	}

	if mmRefillBalanceByUserID.defaultExpectation == nil {
		mmRefillBalanceByUserID.defaultExpectation = &BalanceRepositoryMockRefillBalanceByUserIDExpectation{mock: mmRefillBalanceByUserID.mock}
	}
	mmRefillBalanceByUserID.defaultExpectation.results = &BalanceRepositoryMockRefillBalanceByUserIDResults{err}
	return mmRefillBalanceByUserID.mock
}

// Set uses given function f to mock the Repository.RefillBalanceByUserID method
func (mmRefillBalanceByUserID *mBalanceRepositoryMockRefillBalanceByUserID) Set(f func(ctx context.Context, sum float64, userID string) (err error)) *BalanceRepositoryMock {
	if mmRefillBalanceByUserID.defaultExpectation != nil {
		mmRefillBalanceByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.RefillBalanceByUserID method")
	}

	if len(mmRefillBalanceByUserID.expectations) > 0 {
		mmRefillBalanceByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.RefillBalanceByUserID method")
	}

	mmRefillBalanceByUserID.mock.funcRefillBalanceByUserID = f
	return mmRefillBalanceByUserID.mock
}

// When sets expectation for the Repository.RefillBalanceByUserID which will trigger the result defined by the following
// Then helper
func (mmRefillBalanceByUserID *mBalanceRepositoryMockRefillBalanceByUserID) When(ctx context.Context, sum float64, userID string) *BalanceRepositoryMockRefillBalanceByUserIDExpectation {
	if mmRefillBalanceByUserID.mock.funcRefillBalanceByUserID != nil {
		mmRefillBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.RefillBalanceByUserID mock is already set by Set")
	}

	expectation := &BalanceRepositoryMockRefillBalanceByUserIDExpectation{
		mock:   mmRefillBalanceByUserID.mock,
		params: &BalanceRepositoryMockRefillBalanceByUserIDParams{ctx, sum, userID},
	}
	mmRefillBalanceByUserID.expectations = append(mmRefillBalanceByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.RefillBalanceByUserID return parameters for the expectation previously defined by the When method
func (e *BalanceRepositoryMockRefillBalanceByUserIDExpectation) Then(err error) *BalanceRepositoryMock {
	e.results = &BalanceRepositoryMockRefillBalanceByUserIDResults{err}
	return e.mock
}

// RefillBalanceByUserID implements balance.Repository
func (mmRefillBalanceByUserID *BalanceRepositoryMock) RefillBalanceByUserID(ctx context.Context, sum float64, userID string) (err error) {
	mm_atomic.AddUint64(&mmRefillBalanceByUserID.beforeRefillBalanceByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmRefillBalanceByUserID.afterRefillBalanceByUserIDCounter, 1)

	if mmRefillBalanceByUserID.inspectFuncRefillBalanceByUserID != nil {
		mmRefillBalanceByUserID.inspectFuncRefillBalanceByUserID(ctx, sum, userID)
	}

	mm_params := &BalanceRepositoryMockRefillBalanceByUserIDParams{ctx, sum, userID}

	// Record call args
	mmRefillBalanceByUserID.RefillBalanceByUserIDMock.mutex.Lock()
	mmRefillBalanceByUserID.RefillBalanceByUserIDMock.callArgs = append(mmRefillBalanceByUserID.RefillBalanceByUserIDMock.callArgs, mm_params)
	mmRefillBalanceByUserID.RefillBalanceByUserIDMock.mutex.Unlock()

	for _, e := range mmRefillBalanceByUserID.RefillBalanceByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRefillBalanceByUserID.RefillBalanceByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefillBalanceByUserID.RefillBalanceByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmRefillBalanceByUserID.RefillBalanceByUserIDMock.defaultExpectation.params
		mm_got := BalanceRepositoryMockRefillBalanceByUserIDParams{ctx, sum, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefillBalanceByUserID.t.Errorf("BalanceRepositoryMock.RefillBalanceByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefillBalanceByUserID.RefillBalanceByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmRefillBalanceByUserID.t.Fatal("No results are set for the BalanceRepositoryMock.RefillBalanceByUserID")
		}
		return (*mm_results).err
	}
	if mmRefillBalanceByUserID.funcRefillBalanceByUserID != nil {
		return mmRefillBalanceByUserID.funcRefillBalanceByUserID(ctx, sum, userID)
	}
	mmRefillBalanceByUserID.t.Fatalf("Unexpected call to BalanceRepositoryMock.RefillBalanceByUserID. %v %v %v", ctx, sum, userID)
	return
}

// RefillBalanceByUserIDAfterCounter returns a count of finished BalanceRepositoryMock.RefillBalanceByUserID invocations
func (mmRefillBalanceByUserID *BalanceRepositoryMock) RefillBalanceByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefillBalanceByUserID.afterRefillBalanceByUserIDCounter)
}

// RefillBalanceByUserIDBeforeCounter returns a count of BalanceRepositoryMock.RefillBalanceByUserID invocations
func (mmRefillBalanceByUserID *BalanceRepositoryMock) RefillBalanceByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefillBalanceByUserID.beforeRefillBalanceByUserIDCounter)
}

// Calls returns a list of arguments used in each call to BalanceRepositoryMock.RefillBalanceByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefillBalanceByUserID *mBalanceRepositoryMockRefillBalanceByUserID) Calls() []*BalanceRepositoryMockRefillBalanceByUserIDParams {
	mmRefillBalanceByUserID.mutex.RLock()

	argCopy := make([]*BalanceRepositoryMockRefillBalanceByUserIDParams, len(mmRefillBalanceByUserID.callArgs))
	copy(argCopy, mmRefillBalanceByUserID.callArgs)

	mmRefillBalanceByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockRefillBalanceByUserIDDone returns true if the count of the RefillBalanceByUserID invocations corresponds
// the number of defined expectations
func (m *BalanceRepositoryMock) MinimockRefillBalanceByUserIDDone() bool {
	for _, e := range m.RefillBalanceByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RefillBalanceByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRefillBalanceByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefillBalanceByUserID != nil && mm_atomic.LoadUint64(&m.afterRefillBalanceByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockRefillBalanceByUserIDInspect logs each unmet expectation
func (m *BalanceRepositoryMock) MinimockRefillBalanceByUserIDInspect() {
	for _, e := range m.RefillBalanceByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BalanceRepositoryMock.RefillBalanceByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RefillBalanceByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRefillBalanceByUserIDCounter) < 1 {
		if m.RefillBalanceByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BalanceRepositoryMock.RefillBalanceByUserID")
		} else {
			m.t.Errorf("Expected call to BalanceRepositoryMock.RefillBalanceByUserID with params: %#v", *m.RefillBalanceByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefillBalanceByUserID != nil && mm_atomic.LoadUint64(&m.afterRefillBalanceByUserIDCounter) < 1 {
		m.t.Error("Expected call to BalanceRepositoryMock.RefillBalanceByUserID")
	}
}

type mBalanceRepositoryMockWithdrawBalanceByUserID struct {
	mock               *BalanceRepositoryMock
	defaultExpectation *BalanceRepositoryMockWithdrawBalanceByUserIDExpectation
	expectations       []*BalanceRepositoryMockWithdrawBalanceByUserIDExpectation

	callArgs []*BalanceRepositoryMockWithdrawBalanceByUserIDParams
	mutex    sync.RWMutex
}

// BalanceRepositoryMockWithdrawBalanceByUserIDExpectation specifies expectation struct of the Repository.WithdrawBalanceByUserID
type BalanceRepositoryMockWithdrawBalanceByUserIDExpectation struct {
	mock    *BalanceRepositoryMock
	params  *BalanceRepositoryMockWithdrawBalanceByUserIDParams
	results *BalanceRepositoryMockWithdrawBalanceByUserIDResults
	Counter uint64
}

// BalanceRepositoryMockWithdrawBalanceByUserIDParams contains parameters of the Repository.WithdrawBalanceByUserID
type BalanceRepositoryMockWithdrawBalanceByUserIDParams struct {
	ctx    context.Context
	sum    float64
	userID string
}

// BalanceRepositoryMockWithdrawBalanceByUserIDResults contains results of the Repository.WithdrawBalanceByUserID
type BalanceRepositoryMockWithdrawBalanceByUserIDResults struct {
	err error
}

// Expect sets up expected params for Repository.WithdrawBalanceByUserID
func (mmWithdrawBalanceByUserID *mBalanceRepositoryMockWithdrawBalanceByUserID) Expect(ctx context.Context, sum float64, userID string) *mBalanceRepositoryMockWithdrawBalanceByUserID {
	if mmWithdrawBalanceByUserID.mock.funcWithdrawBalanceByUserID != nil {
		mmWithdrawBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.WithdrawBalanceByUserID mock is already set by Set")
	}

	if mmWithdrawBalanceByUserID.defaultExpectation == nil {
		mmWithdrawBalanceByUserID.defaultExpectation = &BalanceRepositoryMockWithdrawBalanceByUserIDExpectation{}
	}

	mmWithdrawBalanceByUserID.defaultExpectation.params = &BalanceRepositoryMockWithdrawBalanceByUserIDParams{ctx, sum, userID}
	for _, e := range mmWithdrawBalanceByUserID.expectations {
		if minimock.Equal(e.params, mmWithdrawBalanceByUserID.defaultExpectation.params) {
			mmWithdrawBalanceByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithdrawBalanceByUserID.defaultExpectation.params)
		}
	}

	return mmWithdrawBalanceByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.WithdrawBalanceByUserID
func (mmWithdrawBalanceByUserID *mBalanceRepositoryMockWithdrawBalanceByUserID) Inspect(f func(ctx context.Context, sum float64, userID string)) *mBalanceRepositoryMockWithdrawBalanceByUserID {
	if mmWithdrawBalanceByUserID.mock.inspectFuncWithdrawBalanceByUserID != nil {
		mmWithdrawBalanceByUserID.mock.t.Fatalf("Inspect function is already set for BalanceRepositoryMock.WithdrawBalanceByUserID")
	}

	mmWithdrawBalanceByUserID.mock.inspectFuncWithdrawBalanceByUserID = f

	return mmWithdrawBalanceByUserID
}

// Return sets up results that will be returned by Repository.WithdrawBalanceByUserID
func (mmWithdrawBalanceByUserID *mBalanceRepositoryMockWithdrawBalanceByUserID) Return(err error) *BalanceRepositoryMock {
	if mmWithdrawBalanceByUserID.mock.funcWithdrawBalanceByUserID != nil {
		mmWithdrawBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.WithdrawBalanceByUserID mock is already set by Set")
	}

	if mmWithdrawBalanceByUserID.defaultExpectation == nil {
		mmWithdrawBalanceByUserID.defaultExpectation = &BalanceRepositoryMockWithdrawBalanceByUserIDExpectation{mock: mmWithdrawBalanceByUserID.mock}
	}
	mmWithdrawBalanceByUserID.defaultExpectation.results = &BalanceRepositoryMockWithdrawBalanceByUserIDResults{err}
	return mmWithdrawBalanceByUserID.mock
}

// Set uses given function f to mock the Repository.WithdrawBalanceByUserID method
func (mmWithdrawBalanceByUserID *mBalanceRepositoryMockWithdrawBalanceByUserID) Set(f func(ctx context.Context, sum float64, userID string) (err error)) *BalanceRepositoryMock {
	if mmWithdrawBalanceByUserID.defaultExpectation != nil {
		mmWithdrawBalanceByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.WithdrawBalanceByUserID method")
	}

	if len(mmWithdrawBalanceByUserID.expectations) > 0 {
		mmWithdrawBalanceByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.WithdrawBalanceByUserID method")
	}

	mmWithdrawBalanceByUserID.mock.funcWithdrawBalanceByUserID = f
	return mmWithdrawBalanceByUserID.mock
}

// When sets expectation for the Repository.WithdrawBalanceByUserID which will trigger the result defined by the following
// Then helper
func (mmWithdrawBalanceByUserID *mBalanceRepositoryMockWithdrawBalanceByUserID) When(ctx context.Context, sum float64, userID string) *BalanceRepositoryMockWithdrawBalanceByUserIDExpectation {
	if mmWithdrawBalanceByUserID.mock.funcWithdrawBalanceByUserID != nil {
		mmWithdrawBalanceByUserID.mock.t.Fatalf("BalanceRepositoryMock.WithdrawBalanceByUserID mock is already set by Set")
	}

	expectation := &BalanceRepositoryMockWithdrawBalanceByUserIDExpectation{
		mock:   mmWithdrawBalanceByUserID.mock,
		params: &BalanceRepositoryMockWithdrawBalanceByUserIDParams{ctx, sum, userID},
	}
	mmWithdrawBalanceByUserID.expectations = append(mmWithdrawBalanceByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.WithdrawBalanceByUserID return parameters for the expectation previously defined by the When method
func (e *BalanceRepositoryMockWithdrawBalanceByUserIDExpectation) Then(err error) *BalanceRepositoryMock {
	e.results = &BalanceRepositoryMockWithdrawBalanceByUserIDResults{err}
	return e.mock
}

// WithdrawBalanceByUserID implements balance.Repository
func (mmWithdrawBalanceByUserID *BalanceRepositoryMock) WithdrawBalanceByUserID(ctx context.Context, sum float64, userID string) (err error) {
	mm_atomic.AddUint64(&mmWithdrawBalanceByUserID.beforeWithdrawBalanceByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmWithdrawBalanceByUserID.afterWithdrawBalanceByUserIDCounter, 1)

	if mmWithdrawBalanceByUserID.inspectFuncWithdrawBalanceByUserID != nil {
		mmWithdrawBalanceByUserID.inspectFuncWithdrawBalanceByUserID(ctx, sum, userID)
	}

	mm_params := &BalanceRepositoryMockWithdrawBalanceByUserIDParams{ctx, sum, userID}

	// Record call args
	mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.mutex.Lock()
	mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.callArgs = append(mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.callArgs, mm_params)
	mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.mutex.Unlock()

	for _, e := range mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.defaultExpectation.params
		mm_got := BalanceRepositoryMockWithdrawBalanceByUserIDParams{ctx, sum, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithdrawBalanceByUserID.t.Errorf("BalanceRepositoryMock.WithdrawBalanceByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithdrawBalanceByUserID.WithdrawBalanceByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmWithdrawBalanceByUserID.t.Fatal("No results are set for the BalanceRepositoryMock.WithdrawBalanceByUserID")
		}
		return (*mm_results).err
	}
	if mmWithdrawBalanceByUserID.funcWithdrawBalanceByUserID != nil {
		return mmWithdrawBalanceByUserID.funcWithdrawBalanceByUserID(ctx, sum, userID)
	}
	mmWithdrawBalanceByUserID.t.Fatalf("Unexpected call to BalanceRepositoryMock.WithdrawBalanceByUserID. %v %v %v", ctx, sum, userID)
	return
}

// WithdrawBalanceByUserIDAfterCounter returns a count of finished BalanceRepositoryMock.WithdrawBalanceByUserID invocations
func (mmWithdrawBalanceByUserID *BalanceRepositoryMock) WithdrawBalanceByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithdrawBalanceByUserID.afterWithdrawBalanceByUserIDCounter)
}

// WithdrawBalanceByUserIDBeforeCounter returns a count of BalanceRepositoryMock.WithdrawBalanceByUserID invocations
func (mmWithdrawBalanceByUserID *BalanceRepositoryMock) WithdrawBalanceByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithdrawBalanceByUserID.beforeWithdrawBalanceByUserIDCounter)
}

// Calls returns a list of arguments used in each call to BalanceRepositoryMock.WithdrawBalanceByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithdrawBalanceByUserID *mBalanceRepositoryMockWithdrawBalanceByUserID) Calls() []*BalanceRepositoryMockWithdrawBalanceByUserIDParams {
	mmWithdrawBalanceByUserID.mutex.RLock()

	argCopy := make([]*BalanceRepositoryMockWithdrawBalanceByUserIDParams, len(mmWithdrawBalanceByUserID.callArgs))
	copy(argCopy, mmWithdrawBalanceByUserID.callArgs)

	mmWithdrawBalanceByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockWithdrawBalanceByUserIDDone returns true if the count of the WithdrawBalanceByUserID invocations corresponds
// the number of defined expectations
func (m *BalanceRepositoryMock) MinimockWithdrawBalanceByUserIDDone() bool {
	for _, e := range m.WithdrawBalanceByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithdrawBalanceByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithdrawBalanceByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithdrawBalanceByUserID != nil && mm_atomic.LoadUint64(&m.afterWithdrawBalanceByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithdrawBalanceByUserIDInspect logs each unmet expectation
func (m *BalanceRepositoryMock) MinimockWithdrawBalanceByUserIDInspect() {
	for _, e := range m.WithdrawBalanceByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to BalanceRepositoryMock.WithdrawBalanceByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithdrawBalanceByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithdrawBalanceByUserIDCounter) < 1 {
		if m.WithdrawBalanceByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to BalanceRepositoryMock.WithdrawBalanceByUserID")
		} else {
			m.t.Errorf("Expected call to BalanceRepositoryMock.WithdrawBalanceByUserID with params: %#v", *m.WithdrawBalanceByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithdrawBalanceByUserID != nil && mm_atomic.LoadUint64(&m.afterWithdrawBalanceByUserIDCounter) < 1 {
		m.t.Error("Expected call to BalanceRepositoryMock.WithdrawBalanceByUserID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *BalanceRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateBalanceInspect()

		m.MinimockFindBalanceByUserIDInspect()

		m.MinimockRefillBalanceByUserIDInspect()

		m.MinimockWithdrawBalanceByUserIDInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *BalanceRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *BalanceRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateBalanceDone() &&
		m.MinimockFindBalanceByUserIDDone() &&
		m.MinimockRefillBalanceByUserIDDone() &&
		m.MinimockWithdrawBalanceByUserIDDone()
}
