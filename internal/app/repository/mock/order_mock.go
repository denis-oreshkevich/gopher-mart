package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/denis-oreshkevich/gopher-mart/internal/app/domain/order.Repository -o ./internal/app/repository/mock/order_mock.go -n OrderMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_order "github.com/denis-oreshkevich/gopher-mart/internal/app/domain/order"
	"github.com/gojuno/minimock/v3"
)

// OrderMock implements order.Repository
type OrderMock struct {
	t minimock.Tester

	funcCheckIsOrderExist          func(ctx context.Context, orderNum string, userID string) (b1 bool, err error)
	inspectFuncCheckIsOrderExist   func(ctx context.Context, orderNum string, userID string)
	afterCheckIsOrderExistCounter  uint64
	beforeCheckIsOrderExistCounter uint64
	CheckIsOrderExistMock          mOrderMockCheckIsOrderExist

	funcCreateOrder          func(ctx context.Context, orderNum string, userID string) (err error)
	inspectFuncCreateOrder   func(ctx context.Context, orderNum string, userID string)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mOrderMockCreateOrder

	funcFindOrderByNum          func(ctx context.Context, orderNum string) (o1 mm_order.Order, err error)
	inspectFuncFindOrderByNum   func(ctx context.Context, orderNum string)
	afterFindOrderByNumCounter  uint64
	beforeFindOrderByNumCounter uint64
	FindOrderByNumMock          mOrderMockFindOrderByNum

	funcFindOrdersByUserID          func(ctx context.Context, userID string) (oa1 []mm_order.Order, err error)
	inspectFuncFindOrdersByUserID   func(ctx context.Context, userID string)
	afterFindOrdersByUserIDCounter  uint64
	beforeFindOrdersByUserIDCounter uint64
	FindOrdersByUserIDMock          mOrderMockFindOrdersByUserID

	funcStartOrderProcessing          func(ctx context.Context, limit int) (oa1 []mm_order.Order, err error)
	inspectFuncStartOrderProcessing   func(ctx context.Context, limit int)
	afterStartOrderProcessingCounter  uint64
	beforeStartOrderProcessingCounter uint64
	StartOrderProcessingMock          mOrderMockStartOrderProcessing

	funcUpdateOrderStatusByID          func(ctx context.Context, id string, acc float64, status mm_order.Status) (err error)
	inspectFuncUpdateOrderStatusByID   func(ctx context.Context, id string, acc float64, status mm_order.Status)
	afterUpdateOrderStatusByIDCounter  uint64
	beforeUpdateOrderStatusByIDCounter uint64
	UpdateOrderStatusByIDMock          mOrderMockUpdateOrderStatusByID
}

// NewOrderMock returns a mock for order.Repository
func NewOrderMock(t minimock.Tester) *OrderMock {
	m := &OrderMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckIsOrderExistMock = mOrderMockCheckIsOrderExist{mock: m}
	m.CheckIsOrderExistMock.callArgs = []*OrderMockCheckIsOrderExistParams{}

	m.CreateOrderMock = mOrderMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*OrderMockCreateOrderParams{}

	m.FindOrderByNumMock = mOrderMockFindOrderByNum{mock: m}
	m.FindOrderByNumMock.callArgs = []*OrderMockFindOrderByNumParams{}

	m.FindOrdersByUserIDMock = mOrderMockFindOrdersByUserID{mock: m}
	m.FindOrdersByUserIDMock.callArgs = []*OrderMockFindOrdersByUserIDParams{}

	m.StartOrderProcessingMock = mOrderMockStartOrderProcessing{mock: m}
	m.StartOrderProcessingMock.callArgs = []*OrderMockStartOrderProcessingParams{}

	m.UpdateOrderStatusByIDMock = mOrderMockUpdateOrderStatusByID{mock: m}
	m.UpdateOrderStatusByIDMock.callArgs = []*OrderMockUpdateOrderStatusByIDParams{}

	return m
}

type mOrderMockCheckIsOrderExist struct {
	mock               *OrderMock
	defaultExpectation *OrderMockCheckIsOrderExistExpectation
	expectations       []*OrderMockCheckIsOrderExistExpectation

	callArgs []*OrderMockCheckIsOrderExistParams
	mutex    sync.RWMutex
}

// OrderMockCheckIsOrderExistExpectation specifies expectation struct of the Repository.CheckIsOrderExist
type OrderMockCheckIsOrderExistExpectation struct {
	mock    *OrderMock
	params  *OrderMockCheckIsOrderExistParams
	results *OrderMockCheckIsOrderExistResults
	Counter uint64
}

// OrderMockCheckIsOrderExistParams contains parameters of the Repository.CheckIsOrderExist
type OrderMockCheckIsOrderExistParams struct {
	ctx      context.Context
	orderNum string
	userID   string
}

// OrderMockCheckIsOrderExistResults contains results of the Repository.CheckIsOrderExist
type OrderMockCheckIsOrderExistResults struct {
	b1  bool
	err error
}

// Expect sets up expected params for Repository.CheckIsOrderExist
func (mmCheckIsOrderExist *mOrderMockCheckIsOrderExist) Expect(ctx context.Context, orderNum string, userID string) *mOrderMockCheckIsOrderExist {
	if mmCheckIsOrderExist.mock.funcCheckIsOrderExist != nil {
		mmCheckIsOrderExist.mock.t.Fatalf("OrderMock.CheckIsOrderExist mock is already set by Set")
	}

	if mmCheckIsOrderExist.defaultExpectation == nil {
		mmCheckIsOrderExist.defaultExpectation = &OrderMockCheckIsOrderExistExpectation{}
	}

	mmCheckIsOrderExist.defaultExpectation.params = &OrderMockCheckIsOrderExistParams{ctx, orderNum, userID}
	for _, e := range mmCheckIsOrderExist.expectations {
		if minimock.Equal(e.params, mmCheckIsOrderExist.defaultExpectation.params) {
			mmCheckIsOrderExist.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheckIsOrderExist.defaultExpectation.params)
		}
	}

	return mmCheckIsOrderExist
}

// Inspect accepts an inspector function that has same arguments as the Repository.CheckIsOrderExist
func (mmCheckIsOrderExist *mOrderMockCheckIsOrderExist) Inspect(f func(ctx context.Context, orderNum string, userID string)) *mOrderMockCheckIsOrderExist {
	if mmCheckIsOrderExist.mock.inspectFuncCheckIsOrderExist != nil {
		mmCheckIsOrderExist.mock.t.Fatalf("Inspect function is already set for OrderMock.CheckIsOrderExist")
	}

	mmCheckIsOrderExist.mock.inspectFuncCheckIsOrderExist = f

	return mmCheckIsOrderExist
}

// Return sets up results that will be returned by Repository.CheckIsOrderExist
func (mmCheckIsOrderExist *mOrderMockCheckIsOrderExist) Return(b1 bool, err error) *OrderMock {
	if mmCheckIsOrderExist.mock.funcCheckIsOrderExist != nil {
		mmCheckIsOrderExist.mock.t.Fatalf("OrderMock.CheckIsOrderExist mock is already set by Set")
	}

	if mmCheckIsOrderExist.defaultExpectation == nil {
		mmCheckIsOrderExist.defaultExpectation = &OrderMockCheckIsOrderExistExpectation{mock: mmCheckIsOrderExist.mock}
	}
	mmCheckIsOrderExist.defaultExpectation.results = &OrderMockCheckIsOrderExistResults{b1, err}
	return mmCheckIsOrderExist.mock
}

// Set uses given function f to mock the Repository.CheckIsOrderExist method
func (mmCheckIsOrderExist *mOrderMockCheckIsOrderExist) Set(f func(ctx context.Context, orderNum string, userID string) (b1 bool, err error)) *OrderMock {
	if mmCheckIsOrderExist.defaultExpectation != nil {
		mmCheckIsOrderExist.mock.t.Fatalf("Default expectation is already set for the Repository.CheckIsOrderExist method")
	}

	if len(mmCheckIsOrderExist.expectations) > 0 {
		mmCheckIsOrderExist.mock.t.Fatalf("Some expectations are already set for the Repository.CheckIsOrderExist method")
	}

	mmCheckIsOrderExist.mock.funcCheckIsOrderExist = f
	return mmCheckIsOrderExist.mock
}

// When sets expectation for the Repository.CheckIsOrderExist which will trigger the result defined by the following
// Then helper
func (mmCheckIsOrderExist *mOrderMockCheckIsOrderExist) When(ctx context.Context, orderNum string, userID string) *OrderMockCheckIsOrderExistExpectation {
	if mmCheckIsOrderExist.mock.funcCheckIsOrderExist != nil {
		mmCheckIsOrderExist.mock.t.Fatalf("OrderMock.CheckIsOrderExist mock is already set by Set")
	}

	expectation := &OrderMockCheckIsOrderExistExpectation{
		mock:   mmCheckIsOrderExist.mock,
		params: &OrderMockCheckIsOrderExistParams{ctx, orderNum, userID},
	}
	mmCheckIsOrderExist.expectations = append(mmCheckIsOrderExist.expectations, expectation)
	return expectation
}

// Then sets up Repository.CheckIsOrderExist return parameters for the expectation previously defined by the When method
func (e *OrderMockCheckIsOrderExistExpectation) Then(b1 bool, err error) *OrderMock {
	e.results = &OrderMockCheckIsOrderExistResults{b1, err}
	return e.mock
}

// CheckIsOrderExist implements order.Repository
func (mmCheckIsOrderExist *OrderMock) CheckIsOrderExist(ctx context.Context, orderNum string, userID string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheckIsOrderExist.beforeCheckIsOrderExistCounter, 1)
	defer mm_atomic.AddUint64(&mmCheckIsOrderExist.afterCheckIsOrderExistCounter, 1)

	if mmCheckIsOrderExist.inspectFuncCheckIsOrderExist != nil {
		mmCheckIsOrderExist.inspectFuncCheckIsOrderExist(ctx, orderNum, userID)
	}

	mm_params := &OrderMockCheckIsOrderExistParams{ctx, orderNum, userID}

	// Record call args
	mmCheckIsOrderExist.CheckIsOrderExistMock.mutex.Lock()
	mmCheckIsOrderExist.CheckIsOrderExistMock.callArgs = append(mmCheckIsOrderExist.CheckIsOrderExistMock.callArgs, mm_params)
	mmCheckIsOrderExist.CheckIsOrderExistMock.mutex.Unlock()

	for _, e := range mmCheckIsOrderExist.CheckIsOrderExistMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheckIsOrderExist.CheckIsOrderExistMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheckIsOrderExist.CheckIsOrderExistMock.defaultExpectation.Counter, 1)
		mm_want := mmCheckIsOrderExist.CheckIsOrderExistMock.defaultExpectation.params
		mm_got := OrderMockCheckIsOrderExistParams{ctx, orderNum, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheckIsOrderExist.t.Errorf("OrderMock.CheckIsOrderExist got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheckIsOrderExist.CheckIsOrderExistMock.defaultExpectation.results
		if mm_results == nil {
			mmCheckIsOrderExist.t.Fatal("No results are set for the OrderMock.CheckIsOrderExist")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheckIsOrderExist.funcCheckIsOrderExist != nil {
		return mmCheckIsOrderExist.funcCheckIsOrderExist(ctx, orderNum, userID)
	}
	mmCheckIsOrderExist.t.Fatalf("Unexpected call to OrderMock.CheckIsOrderExist. %v %v %v", ctx, orderNum, userID)
	return
}

// CheckIsOrderExistAfterCounter returns a count of finished OrderMock.CheckIsOrderExist invocations
func (mmCheckIsOrderExist *OrderMock) CheckIsOrderExistAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIsOrderExist.afterCheckIsOrderExistCounter)
}

// CheckIsOrderExistBeforeCounter returns a count of OrderMock.CheckIsOrderExist invocations
func (mmCheckIsOrderExist *OrderMock) CheckIsOrderExistBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheckIsOrderExist.beforeCheckIsOrderExistCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.CheckIsOrderExist.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheckIsOrderExist *mOrderMockCheckIsOrderExist) Calls() []*OrderMockCheckIsOrderExistParams {
	mmCheckIsOrderExist.mutex.RLock()

	argCopy := make([]*OrderMockCheckIsOrderExistParams, len(mmCheckIsOrderExist.callArgs))
	copy(argCopy, mmCheckIsOrderExist.callArgs)

	mmCheckIsOrderExist.mutex.RUnlock()

	return argCopy
}

// MinimockCheckIsOrderExistDone returns true if the count of the CheckIsOrderExist invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockCheckIsOrderExistDone() bool {
	for _, e := range m.CheckIsOrderExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckIsOrderExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckIsOrderExistCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckIsOrderExist != nil && mm_atomic.LoadUint64(&m.afterCheckIsOrderExistCounter) < 1 {
		return false
	}
	return true
}

// MinimockCheckIsOrderExistInspect logs each unmet expectation
func (m *OrderMock) MinimockCheckIsOrderExistInspect() {
	for _, e := range m.CheckIsOrderExistMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.CheckIsOrderExist with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CheckIsOrderExistMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCheckIsOrderExistCounter) < 1 {
		if m.CheckIsOrderExistMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderMock.CheckIsOrderExist")
		} else {
			m.t.Errorf("Expected call to OrderMock.CheckIsOrderExist with params: %#v", *m.CheckIsOrderExistMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheckIsOrderExist != nil && mm_atomic.LoadUint64(&m.afterCheckIsOrderExistCounter) < 1 {
		m.t.Error("Expected call to OrderMock.CheckIsOrderExist")
	}
}

type mOrderMockCreateOrder struct {
	mock               *OrderMock
	defaultExpectation *OrderMockCreateOrderExpectation
	expectations       []*OrderMockCreateOrderExpectation

	callArgs []*OrderMockCreateOrderParams
	mutex    sync.RWMutex
}

// OrderMockCreateOrderExpectation specifies expectation struct of the Repository.CreateOrder
type OrderMockCreateOrderExpectation struct {
	mock    *OrderMock
	params  *OrderMockCreateOrderParams
	results *OrderMockCreateOrderResults
	Counter uint64
}

// OrderMockCreateOrderParams contains parameters of the Repository.CreateOrder
type OrderMockCreateOrderParams struct {
	ctx      context.Context
	orderNum string
	userID   string
}

// OrderMockCreateOrderResults contains results of the Repository.CreateOrder
type OrderMockCreateOrderResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) Expect(ctx context.Context, orderNum string, userID string) *mOrderMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &OrderMockCreateOrderParams{ctx, orderNum, userID}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) Inspect(f func(ctx context.Context, orderNum string, userID string)) *mOrderMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for OrderMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by Repository.CreateOrder
func (mmCreateOrder *mOrderMockCreateOrder) Return(err error) *OrderMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &OrderMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &OrderMockCreateOrderResults{err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the Repository.CreateOrder method
func (mmCreateOrder *mOrderMockCreateOrder) Set(f func(ctx context.Context, orderNum string, userID string) (err error)) *OrderMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the Repository.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the Repository.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the Repository.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mOrderMockCreateOrder) When(ctx context.Context, orderNum string, userID string) *OrderMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("OrderMock.CreateOrder mock is already set by Set")
	}

	expectation := &OrderMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &OrderMockCreateOrderParams{ctx, orderNum, userID},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateOrder return parameters for the expectation previously defined by the When method
func (e *OrderMockCreateOrderExpectation) Then(err error) *OrderMock {
	e.results = &OrderMockCreateOrderResults{err}
	return e.mock
}

// CreateOrder implements order.Repository
func (mmCreateOrder *OrderMock) CreateOrder(ctx context.Context, orderNum string, userID string) (err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, orderNum, userID)
	}

	mm_params := &OrderMockCreateOrderParams{ctx, orderNum, userID}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := OrderMockCreateOrderParams{ctx, orderNum, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("OrderMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the OrderMock.CreateOrder")
		}
		return (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, orderNum, userID)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to OrderMock.CreateOrder. %v %v %v", ctx, orderNum, userID)
	return
}

// CreateOrderAfterCounter returns a count of finished OrderMock.CreateOrder invocations
func (mmCreateOrder *OrderMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of OrderMock.CreateOrder invocations
func (mmCreateOrder *OrderMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mOrderMockCreateOrder) Calls() []*OrderMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*OrderMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *OrderMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to OrderMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to OrderMock.CreateOrder")
	}
}

type mOrderMockFindOrderByNum struct {
	mock               *OrderMock
	defaultExpectation *OrderMockFindOrderByNumExpectation
	expectations       []*OrderMockFindOrderByNumExpectation

	callArgs []*OrderMockFindOrderByNumParams
	mutex    sync.RWMutex
}

// OrderMockFindOrderByNumExpectation specifies expectation struct of the Repository.FindOrderByNum
type OrderMockFindOrderByNumExpectation struct {
	mock    *OrderMock
	params  *OrderMockFindOrderByNumParams
	results *OrderMockFindOrderByNumResults
	Counter uint64
}

// OrderMockFindOrderByNumParams contains parameters of the Repository.FindOrderByNum
type OrderMockFindOrderByNumParams struct {
	ctx      context.Context
	orderNum string
}

// OrderMockFindOrderByNumResults contains results of the Repository.FindOrderByNum
type OrderMockFindOrderByNumResults struct {
	o1  mm_order.Order
	err error
}

// Expect sets up expected params for Repository.FindOrderByNum
func (mmFindOrderByNum *mOrderMockFindOrderByNum) Expect(ctx context.Context, orderNum string) *mOrderMockFindOrderByNum {
	if mmFindOrderByNum.mock.funcFindOrderByNum != nil {
		mmFindOrderByNum.mock.t.Fatalf("OrderMock.FindOrderByNum mock is already set by Set")
	}

	if mmFindOrderByNum.defaultExpectation == nil {
		mmFindOrderByNum.defaultExpectation = &OrderMockFindOrderByNumExpectation{}
	}

	mmFindOrderByNum.defaultExpectation.params = &OrderMockFindOrderByNumParams{ctx, orderNum}
	for _, e := range mmFindOrderByNum.expectations {
		if minimock.Equal(e.params, mmFindOrderByNum.defaultExpectation.params) {
			mmFindOrderByNum.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOrderByNum.defaultExpectation.params)
		}
	}

	return mmFindOrderByNum
}

// Inspect accepts an inspector function that has same arguments as the Repository.FindOrderByNum
func (mmFindOrderByNum *mOrderMockFindOrderByNum) Inspect(f func(ctx context.Context, orderNum string)) *mOrderMockFindOrderByNum {
	if mmFindOrderByNum.mock.inspectFuncFindOrderByNum != nil {
		mmFindOrderByNum.mock.t.Fatalf("Inspect function is already set for OrderMock.FindOrderByNum")
	}

	mmFindOrderByNum.mock.inspectFuncFindOrderByNum = f

	return mmFindOrderByNum
}

// Return sets up results that will be returned by Repository.FindOrderByNum
func (mmFindOrderByNum *mOrderMockFindOrderByNum) Return(o1 mm_order.Order, err error) *OrderMock {
	if mmFindOrderByNum.mock.funcFindOrderByNum != nil {
		mmFindOrderByNum.mock.t.Fatalf("OrderMock.FindOrderByNum mock is already set by Set")
	}

	if mmFindOrderByNum.defaultExpectation == nil {
		mmFindOrderByNum.defaultExpectation = &OrderMockFindOrderByNumExpectation{mock: mmFindOrderByNum.mock}
	}
	mmFindOrderByNum.defaultExpectation.results = &OrderMockFindOrderByNumResults{o1, err}
	return mmFindOrderByNum.mock
}

// Set uses given function f to mock the Repository.FindOrderByNum method
func (mmFindOrderByNum *mOrderMockFindOrderByNum) Set(f func(ctx context.Context, orderNum string) (o1 mm_order.Order, err error)) *OrderMock {
	if mmFindOrderByNum.defaultExpectation != nil {
		mmFindOrderByNum.mock.t.Fatalf("Default expectation is already set for the Repository.FindOrderByNum method")
	}

	if len(mmFindOrderByNum.expectations) > 0 {
		mmFindOrderByNum.mock.t.Fatalf("Some expectations are already set for the Repository.FindOrderByNum method")
	}

	mmFindOrderByNum.mock.funcFindOrderByNum = f
	return mmFindOrderByNum.mock
}

// When sets expectation for the Repository.FindOrderByNum which will trigger the result defined by the following
// Then helper
func (mmFindOrderByNum *mOrderMockFindOrderByNum) When(ctx context.Context, orderNum string) *OrderMockFindOrderByNumExpectation {
	if mmFindOrderByNum.mock.funcFindOrderByNum != nil {
		mmFindOrderByNum.mock.t.Fatalf("OrderMock.FindOrderByNum mock is already set by Set")
	}

	expectation := &OrderMockFindOrderByNumExpectation{
		mock:   mmFindOrderByNum.mock,
		params: &OrderMockFindOrderByNumParams{ctx, orderNum},
	}
	mmFindOrderByNum.expectations = append(mmFindOrderByNum.expectations, expectation)
	return expectation
}

// Then sets up Repository.FindOrderByNum return parameters for the expectation previously defined by the When method
func (e *OrderMockFindOrderByNumExpectation) Then(o1 mm_order.Order, err error) *OrderMock {
	e.results = &OrderMockFindOrderByNumResults{o1, err}
	return e.mock
}

// FindOrderByNum implements order.Repository
func (mmFindOrderByNum *OrderMock) FindOrderByNum(ctx context.Context, orderNum string) (o1 mm_order.Order, err error) {
	mm_atomic.AddUint64(&mmFindOrderByNum.beforeFindOrderByNumCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOrderByNum.afterFindOrderByNumCounter, 1)

	if mmFindOrderByNum.inspectFuncFindOrderByNum != nil {
		mmFindOrderByNum.inspectFuncFindOrderByNum(ctx, orderNum)
	}

	mm_params := &OrderMockFindOrderByNumParams{ctx, orderNum}

	// Record call args
	mmFindOrderByNum.FindOrderByNumMock.mutex.Lock()
	mmFindOrderByNum.FindOrderByNumMock.callArgs = append(mmFindOrderByNum.FindOrderByNumMock.callArgs, mm_params)
	mmFindOrderByNum.FindOrderByNumMock.mutex.Unlock()

	for _, e := range mmFindOrderByNum.FindOrderByNumMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmFindOrderByNum.FindOrderByNumMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOrderByNum.FindOrderByNumMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOrderByNum.FindOrderByNumMock.defaultExpectation.params
		mm_got := OrderMockFindOrderByNumParams{ctx, orderNum}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOrderByNum.t.Errorf("OrderMock.FindOrderByNum got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOrderByNum.FindOrderByNumMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOrderByNum.t.Fatal("No results are set for the OrderMock.FindOrderByNum")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmFindOrderByNum.funcFindOrderByNum != nil {
		return mmFindOrderByNum.funcFindOrderByNum(ctx, orderNum)
	}
	mmFindOrderByNum.t.Fatalf("Unexpected call to OrderMock.FindOrderByNum. %v %v", ctx, orderNum)
	return
}

// FindOrderByNumAfterCounter returns a count of finished OrderMock.FindOrderByNum invocations
func (mmFindOrderByNum *OrderMock) FindOrderByNumAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOrderByNum.afterFindOrderByNumCounter)
}

// FindOrderByNumBeforeCounter returns a count of OrderMock.FindOrderByNum invocations
func (mmFindOrderByNum *OrderMock) FindOrderByNumBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOrderByNum.beforeFindOrderByNumCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.FindOrderByNum.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOrderByNum *mOrderMockFindOrderByNum) Calls() []*OrderMockFindOrderByNumParams {
	mmFindOrderByNum.mutex.RLock()

	argCopy := make([]*OrderMockFindOrderByNumParams, len(mmFindOrderByNum.callArgs))
	copy(argCopy, mmFindOrderByNum.callArgs)

	mmFindOrderByNum.mutex.RUnlock()

	return argCopy
}

// MinimockFindOrderByNumDone returns true if the count of the FindOrderByNum invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockFindOrderByNumDone() bool {
	for _, e := range m.FindOrderByNumMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindOrderByNumMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindOrderByNumCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOrderByNum != nil && mm_atomic.LoadUint64(&m.afterFindOrderByNumCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindOrderByNumInspect logs each unmet expectation
func (m *OrderMock) MinimockFindOrderByNumInspect() {
	for _, e := range m.FindOrderByNumMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.FindOrderByNum with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindOrderByNumMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindOrderByNumCounter) < 1 {
		if m.FindOrderByNumMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderMock.FindOrderByNum")
		} else {
			m.t.Errorf("Expected call to OrderMock.FindOrderByNum with params: %#v", *m.FindOrderByNumMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOrderByNum != nil && mm_atomic.LoadUint64(&m.afterFindOrderByNumCounter) < 1 {
		m.t.Error("Expected call to OrderMock.FindOrderByNum")
	}
}

type mOrderMockFindOrdersByUserID struct {
	mock               *OrderMock
	defaultExpectation *OrderMockFindOrdersByUserIDExpectation
	expectations       []*OrderMockFindOrdersByUserIDExpectation

	callArgs []*OrderMockFindOrdersByUserIDParams
	mutex    sync.RWMutex
}

// OrderMockFindOrdersByUserIDExpectation specifies expectation struct of the Repository.FindOrdersByUserID
type OrderMockFindOrdersByUserIDExpectation struct {
	mock    *OrderMock
	params  *OrderMockFindOrdersByUserIDParams
	results *OrderMockFindOrdersByUserIDResults
	Counter uint64
}

// OrderMockFindOrdersByUserIDParams contains parameters of the Repository.FindOrdersByUserID
type OrderMockFindOrdersByUserIDParams struct {
	ctx    context.Context
	userID string
}

// OrderMockFindOrdersByUserIDResults contains results of the Repository.FindOrdersByUserID
type OrderMockFindOrdersByUserIDResults struct {
	oa1 []mm_order.Order
	err error
}

// Expect sets up expected params for Repository.FindOrdersByUserID
func (mmFindOrdersByUserID *mOrderMockFindOrdersByUserID) Expect(ctx context.Context, userID string) *mOrderMockFindOrdersByUserID {
	if mmFindOrdersByUserID.mock.funcFindOrdersByUserID != nil {
		mmFindOrdersByUserID.mock.t.Fatalf("OrderMock.FindOrdersByUserID mock is already set by Set")
	}

	if mmFindOrdersByUserID.defaultExpectation == nil {
		mmFindOrdersByUserID.defaultExpectation = &OrderMockFindOrdersByUserIDExpectation{}
	}

	mmFindOrdersByUserID.defaultExpectation.params = &OrderMockFindOrdersByUserIDParams{ctx, userID}
	for _, e := range mmFindOrdersByUserID.expectations {
		if minimock.Equal(e.params, mmFindOrdersByUserID.defaultExpectation.params) {
			mmFindOrdersByUserID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmFindOrdersByUserID.defaultExpectation.params)
		}
	}

	return mmFindOrdersByUserID
}

// Inspect accepts an inspector function that has same arguments as the Repository.FindOrdersByUserID
func (mmFindOrdersByUserID *mOrderMockFindOrdersByUserID) Inspect(f func(ctx context.Context, userID string)) *mOrderMockFindOrdersByUserID {
	if mmFindOrdersByUserID.mock.inspectFuncFindOrdersByUserID != nil {
		mmFindOrdersByUserID.mock.t.Fatalf("Inspect function is already set for OrderMock.FindOrdersByUserID")
	}

	mmFindOrdersByUserID.mock.inspectFuncFindOrdersByUserID = f

	return mmFindOrdersByUserID
}

// Return sets up results that will be returned by Repository.FindOrdersByUserID
func (mmFindOrdersByUserID *mOrderMockFindOrdersByUserID) Return(oa1 []mm_order.Order, err error) *OrderMock {
	if mmFindOrdersByUserID.mock.funcFindOrdersByUserID != nil {
		mmFindOrdersByUserID.mock.t.Fatalf("OrderMock.FindOrdersByUserID mock is already set by Set")
	}

	if mmFindOrdersByUserID.defaultExpectation == nil {
		mmFindOrdersByUserID.defaultExpectation = &OrderMockFindOrdersByUserIDExpectation{mock: mmFindOrdersByUserID.mock}
	}
	mmFindOrdersByUserID.defaultExpectation.results = &OrderMockFindOrdersByUserIDResults{oa1, err}
	return mmFindOrdersByUserID.mock
}

// Set uses given function f to mock the Repository.FindOrdersByUserID method
func (mmFindOrdersByUserID *mOrderMockFindOrdersByUserID) Set(f func(ctx context.Context, userID string) (oa1 []mm_order.Order, err error)) *OrderMock {
	if mmFindOrdersByUserID.defaultExpectation != nil {
		mmFindOrdersByUserID.mock.t.Fatalf("Default expectation is already set for the Repository.FindOrdersByUserID method")
	}

	if len(mmFindOrdersByUserID.expectations) > 0 {
		mmFindOrdersByUserID.mock.t.Fatalf("Some expectations are already set for the Repository.FindOrdersByUserID method")
	}

	mmFindOrdersByUserID.mock.funcFindOrdersByUserID = f
	return mmFindOrdersByUserID.mock
}

// When sets expectation for the Repository.FindOrdersByUserID which will trigger the result defined by the following
// Then helper
func (mmFindOrdersByUserID *mOrderMockFindOrdersByUserID) When(ctx context.Context, userID string) *OrderMockFindOrdersByUserIDExpectation {
	if mmFindOrdersByUserID.mock.funcFindOrdersByUserID != nil {
		mmFindOrdersByUserID.mock.t.Fatalf("OrderMock.FindOrdersByUserID mock is already set by Set")
	}

	expectation := &OrderMockFindOrdersByUserIDExpectation{
		mock:   mmFindOrdersByUserID.mock,
		params: &OrderMockFindOrdersByUserIDParams{ctx, userID},
	}
	mmFindOrdersByUserID.expectations = append(mmFindOrdersByUserID.expectations, expectation)
	return expectation
}

// Then sets up Repository.FindOrdersByUserID return parameters for the expectation previously defined by the When method
func (e *OrderMockFindOrdersByUserIDExpectation) Then(oa1 []mm_order.Order, err error) *OrderMock {
	e.results = &OrderMockFindOrdersByUserIDResults{oa1, err}
	return e.mock
}

// FindOrdersByUserID implements order.Repository
func (mmFindOrdersByUserID *OrderMock) FindOrdersByUserID(ctx context.Context, userID string) (oa1 []mm_order.Order, err error) {
	mm_atomic.AddUint64(&mmFindOrdersByUserID.beforeFindOrdersByUserIDCounter, 1)
	defer mm_atomic.AddUint64(&mmFindOrdersByUserID.afterFindOrdersByUserIDCounter, 1)

	if mmFindOrdersByUserID.inspectFuncFindOrdersByUserID != nil {
		mmFindOrdersByUserID.inspectFuncFindOrdersByUserID(ctx, userID)
	}

	mm_params := &OrderMockFindOrdersByUserIDParams{ctx, userID}

	// Record call args
	mmFindOrdersByUserID.FindOrdersByUserIDMock.mutex.Lock()
	mmFindOrdersByUserID.FindOrdersByUserIDMock.callArgs = append(mmFindOrdersByUserID.FindOrdersByUserIDMock.callArgs, mm_params)
	mmFindOrdersByUserID.FindOrdersByUserIDMock.mutex.Unlock()

	for _, e := range mmFindOrdersByUserID.FindOrdersByUserIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmFindOrdersByUserID.FindOrdersByUserIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFindOrdersByUserID.FindOrdersByUserIDMock.defaultExpectation.Counter, 1)
		mm_want := mmFindOrdersByUserID.FindOrdersByUserIDMock.defaultExpectation.params
		mm_got := OrderMockFindOrdersByUserIDParams{ctx, userID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmFindOrdersByUserID.t.Errorf("OrderMock.FindOrdersByUserID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmFindOrdersByUserID.FindOrdersByUserIDMock.defaultExpectation.results
		if mm_results == nil {
			mmFindOrdersByUserID.t.Fatal("No results are set for the OrderMock.FindOrdersByUserID")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmFindOrdersByUserID.funcFindOrdersByUserID != nil {
		return mmFindOrdersByUserID.funcFindOrdersByUserID(ctx, userID)
	}
	mmFindOrdersByUserID.t.Fatalf("Unexpected call to OrderMock.FindOrdersByUserID. %v %v", ctx, userID)
	return
}

// FindOrdersByUserIDAfterCounter returns a count of finished OrderMock.FindOrdersByUserID invocations
func (mmFindOrdersByUserID *OrderMock) FindOrdersByUserIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOrdersByUserID.afterFindOrdersByUserIDCounter)
}

// FindOrdersByUserIDBeforeCounter returns a count of OrderMock.FindOrdersByUserID invocations
func (mmFindOrdersByUserID *OrderMock) FindOrdersByUserIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFindOrdersByUserID.beforeFindOrdersByUserIDCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.FindOrdersByUserID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmFindOrdersByUserID *mOrderMockFindOrdersByUserID) Calls() []*OrderMockFindOrdersByUserIDParams {
	mmFindOrdersByUserID.mutex.RLock()

	argCopy := make([]*OrderMockFindOrdersByUserIDParams, len(mmFindOrdersByUserID.callArgs))
	copy(argCopy, mmFindOrdersByUserID.callArgs)

	mmFindOrdersByUserID.mutex.RUnlock()

	return argCopy
}

// MinimockFindOrdersByUserIDDone returns true if the count of the FindOrdersByUserID invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockFindOrdersByUserIDDone() bool {
	for _, e := range m.FindOrdersByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindOrdersByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindOrdersByUserIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOrdersByUserID != nil && mm_atomic.LoadUint64(&m.afterFindOrdersByUserIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockFindOrdersByUserIDInspect logs each unmet expectation
func (m *OrderMock) MinimockFindOrdersByUserIDInspect() {
	for _, e := range m.FindOrdersByUserIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.FindOrdersByUserID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.FindOrdersByUserIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterFindOrdersByUserIDCounter) < 1 {
		if m.FindOrdersByUserIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderMock.FindOrdersByUserID")
		} else {
			m.t.Errorf("Expected call to OrderMock.FindOrdersByUserID with params: %#v", *m.FindOrdersByUserIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFindOrdersByUserID != nil && mm_atomic.LoadUint64(&m.afterFindOrdersByUserIDCounter) < 1 {
		m.t.Error("Expected call to OrderMock.FindOrdersByUserID")
	}
}

type mOrderMockStartOrderProcessing struct {
	mock               *OrderMock
	defaultExpectation *OrderMockStartOrderProcessingExpectation
	expectations       []*OrderMockStartOrderProcessingExpectation

	callArgs []*OrderMockStartOrderProcessingParams
	mutex    sync.RWMutex
}

// OrderMockStartOrderProcessingExpectation specifies expectation struct of the Repository.StartOrderProcessing
type OrderMockStartOrderProcessingExpectation struct {
	mock    *OrderMock
	params  *OrderMockStartOrderProcessingParams
	results *OrderMockStartOrderProcessingResults
	Counter uint64
}

// OrderMockStartOrderProcessingParams contains parameters of the Repository.StartOrderProcessing
type OrderMockStartOrderProcessingParams struct {
	ctx   context.Context
	limit int
}

// OrderMockStartOrderProcessingResults contains results of the Repository.StartOrderProcessing
type OrderMockStartOrderProcessingResults struct {
	oa1 []mm_order.Order
	err error
}

// Expect sets up expected params for Repository.StartOrderProcessing
func (mmStartOrderProcessing *mOrderMockStartOrderProcessing) Expect(ctx context.Context, limit int) *mOrderMockStartOrderProcessing {
	if mmStartOrderProcessing.mock.funcStartOrderProcessing != nil {
		mmStartOrderProcessing.mock.t.Fatalf("OrderMock.StartOrderProcessing mock is already set by Set")
	}

	if mmStartOrderProcessing.defaultExpectation == nil {
		mmStartOrderProcessing.defaultExpectation = &OrderMockStartOrderProcessingExpectation{}
	}

	mmStartOrderProcessing.defaultExpectation.params = &OrderMockStartOrderProcessingParams{ctx, limit}
	for _, e := range mmStartOrderProcessing.expectations {
		if minimock.Equal(e.params, mmStartOrderProcessing.defaultExpectation.params) {
			mmStartOrderProcessing.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStartOrderProcessing.defaultExpectation.params)
		}
	}

	return mmStartOrderProcessing
}

// Inspect accepts an inspector function that has same arguments as the Repository.StartOrderProcessing
func (mmStartOrderProcessing *mOrderMockStartOrderProcessing) Inspect(f func(ctx context.Context, limit int)) *mOrderMockStartOrderProcessing {
	if mmStartOrderProcessing.mock.inspectFuncStartOrderProcessing != nil {
		mmStartOrderProcessing.mock.t.Fatalf("Inspect function is already set for OrderMock.StartOrderProcessing")
	}

	mmStartOrderProcessing.mock.inspectFuncStartOrderProcessing = f

	return mmStartOrderProcessing
}

// Return sets up results that will be returned by Repository.StartOrderProcessing
func (mmStartOrderProcessing *mOrderMockStartOrderProcessing) Return(oa1 []mm_order.Order, err error) *OrderMock {
	if mmStartOrderProcessing.mock.funcStartOrderProcessing != nil {
		mmStartOrderProcessing.mock.t.Fatalf("OrderMock.StartOrderProcessing mock is already set by Set")
	}

	if mmStartOrderProcessing.defaultExpectation == nil {
		mmStartOrderProcessing.defaultExpectation = &OrderMockStartOrderProcessingExpectation{mock: mmStartOrderProcessing.mock}
	}
	mmStartOrderProcessing.defaultExpectation.results = &OrderMockStartOrderProcessingResults{oa1, err}
	return mmStartOrderProcessing.mock
}

// Set uses given function f to mock the Repository.StartOrderProcessing method
func (mmStartOrderProcessing *mOrderMockStartOrderProcessing) Set(f func(ctx context.Context, limit int) (oa1 []mm_order.Order, err error)) *OrderMock {
	if mmStartOrderProcessing.defaultExpectation != nil {
		mmStartOrderProcessing.mock.t.Fatalf("Default expectation is already set for the Repository.StartOrderProcessing method")
	}

	if len(mmStartOrderProcessing.expectations) > 0 {
		mmStartOrderProcessing.mock.t.Fatalf("Some expectations are already set for the Repository.StartOrderProcessing method")
	}

	mmStartOrderProcessing.mock.funcStartOrderProcessing = f
	return mmStartOrderProcessing.mock
}

// When sets expectation for the Repository.StartOrderProcessing which will trigger the result defined by the following
// Then helper
func (mmStartOrderProcessing *mOrderMockStartOrderProcessing) When(ctx context.Context, limit int) *OrderMockStartOrderProcessingExpectation {
	if mmStartOrderProcessing.mock.funcStartOrderProcessing != nil {
		mmStartOrderProcessing.mock.t.Fatalf("OrderMock.StartOrderProcessing mock is already set by Set")
	}

	expectation := &OrderMockStartOrderProcessingExpectation{
		mock:   mmStartOrderProcessing.mock,
		params: &OrderMockStartOrderProcessingParams{ctx, limit},
	}
	mmStartOrderProcessing.expectations = append(mmStartOrderProcessing.expectations, expectation)
	return expectation
}

// Then sets up Repository.StartOrderProcessing return parameters for the expectation previously defined by the When method
func (e *OrderMockStartOrderProcessingExpectation) Then(oa1 []mm_order.Order, err error) *OrderMock {
	e.results = &OrderMockStartOrderProcessingResults{oa1, err}
	return e.mock
}

// StartOrderProcessing implements order.Repository
func (mmStartOrderProcessing *OrderMock) StartOrderProcessing(ctx context.Context, limit int) (oa1 []mm_order.Order, err error) {
	mm_atomic.AddUint64(&mmStartOrderProcessing.beforeStartOrderProcessingCounter, 1)
	defer mm_atomic.AddUint64(&mmStartOrderProcessing.afterStartOrderProcessingCounter, 1)

	if mmStartOrderProcessing.inspectFuncStartOrderProcessing != nil {
		mmStartOrderProcessing.inspectFuncStartOrderProcessing(ctx, limit)
	}

	mm_params := &OrderMockStartOrderProcessingParams{ctx, limit}

	// Record call args
	mmStartOrderProcessing.StartOrderProcessingMock.mutex.Lock()
	mmStartOrderProcessing.StartOrderProcessingMock.callArgs = append(mmStartOrderProcessing.StartOrderProcessingMock.callArgs, mm_params)
	mmStartOrderProcessing.StartOrderProcessingMock.mutex.Unlock()

	for _, e := range mmStartOrderProcessing.StartOrderProcessingMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmStartOrderProcessing.StartOrderProcessingMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStartOrderProcessing.StartOrderProcessingMock.defaultExpectation.Counter, 1)
		mm_want := mmStartOrderProcessing.StartOrderProcessingMock.defaultExpectation.params
		mm_got := OrderMockStartOrderProcessingParams{ctx, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStartOrderProcessing.t.Errorf("OrderMock.StartOrderProcessing got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStartOrderProcessing.StartOrderProcessingMock.defaultExpectation.results
		if mm_results == nil {
			mmStartOrderProcessing.t.Fatal("No results are set for the OrderMock.StartOrderProcessing")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmStartOrderProcessing.funcStartOrderProcessing != nil {
		return mmStartOrderProcessing.funcStartOrderProcessing(ctx, limit)
	}
	mmStartOrderProcessing.t.Fatalf("Unexpected call to OrderMock.StartOrderProcessing. %v %v", ctx, limit)
	return
}

// StartOrderProcessingAfterCounter returns a count of finished OrderMock.StartOrderProcessing invocations
func (mmStartOrderProcessing *OrderMock) StartOrderProcessingAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartOrderProcessing.afterStartOrderProcessingCounter)
}

// StartOrderProcessingBeforeCounter returns a count of OrderMock.StartOrderProcessing invocations
func (mmStartOrderProcessing *OrderMock) StartOrderProcessingBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStartOrderProcessing.beforeStartOrderProcessingCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.StartOrderProcessing.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStartOrderProcessing *mOrderMockStartOrderProcessing) Calls() []*OrderMockStartOrderProcessingParams {
	mmStartOrderProcessing.mutex.RLock()

	argCopy := make([]*OrderMockStartOrderProcessingParams, len(mmStartOrderProcessing.callArgs))
	copy(argCopy, mmStartOrderProcessing.callArgs)

	mmStartOrderProcessing.mutex.RUnlock()

	return argCopy
}

// MinimockStartOrderProcessingDone returns true if the count of the StartOrderProcessing invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockStartOrderProcessingDone() bool {
	for _, e := range m.StartOrderProcessingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartOrderProcessingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartOrderProcessingCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartOrderProcessing != nil && mm_atomic.LoadUint64(&m.afterStartOrderProcessingCounter) < 1 {
		return false
	}
	return true
}

// MinimockStartOrderProcessingInspect logs each unmet expectation
func (m *OrderMock) MinimockStartOrderProcessingInspect() {
	for _, e := range m.StartOrderProcessingMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.StartOrderProcessing with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StartOrderProcessingMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStartOrderProcessingCounter) < 1 {
		if m.StartOrderProcessingMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderMock.StartOrderProcessing")
		} else {
			m.t.Errorf("Expected call to OrderMock.StartOrderProcessing with params: %#v", *m.StartOrderProcessingMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStartOrderProcessing != nil && mm_atomic.LoadUint64(&m.afterStartOrderProcessingCounter) < 1 {
		m.t.Error("Expected call to OrderMock.StartOrderProcessing")
	}
}

type mOrderMockUpdateOrderStatusByID struct {
	mock               *OrderMock
	defaultExpectation *OrderMockUpdateOrderStatusByIDExpectation
	expectations       []*OrderMockUpdateOrderStatusByIDExpectation

	callArgs []*OrderMockUpdateOrderStatusByIDParams
	mutex    sync.RWMutex
}

// OrderMockUpdateOrderStatusByIDExpectation specifies expectation struct of the Repository.UpdateOrderStatusByID
type OrderMockUpdateOrderStatusByIDExpectation struct {
	mock    *OrderMock
	params  *OrderMockUpdateOrderStatusByIDParams
	results *OrderMockUpdateOrderStatusByIDResults
	Counter uint64
}

// OrderMockUpdateOrderStatusByIDParams contains parameters of the Repository.UpdateOrderStatusByID
type OrderMockUpdateOrderStatusByIDParams struct {
	ctx    context.Context
	id     string
	acc    float64
	status mm_order.Status
}

// OrderMockUpdateOrderStatusByIDResults contains results of the Repository.UpdateOrderStatusByID
type OrderMockUpdateOrderStatusByIDResults struct {
	err error
}

// Expect sets up expected params for Repository.UpdateOrderStatusByID
func (mmUpdateOrderStatusByID *mOrderMockUpdateOrderStatusByID) Expect(ctx context.Context, id string, acc float64, status mm_order.Status) *mOrderMockUpdateOrderStatusByID {
	if mmUpdateOrderStatusByID.mock.funcUpdateOrderStatusByID != nil {
		mmUpdateOrderStatusByID.mock.t.Fatalf("OrderMock.UpdateOrderStatusByID mock is already set by Set")
	}

	if mmUpdateOrderStatusByID.defaultExpectation == nil {
		mmUpdateOrderStatusByID.defaultExpectation = &OrderMockUpdateOrderStatusByIDExpectation{}
	}

	mmUpdateOrderStatusByID.defaultExpectation.params = &OrderMockUpdateOrderStatusByIDParams{ctx, id, acc, status}
	for _, e := range mmUpdateOrderStatusByID.expectations {
		if minimock.Equal(e.params, mmUpdateOrderStatusByID.defaultExpectation.params) {
			mmUpdateOrderStatusByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrderStatusByID.defaultExpectation.params)
		}
	}

	return mmUpdateOrderStatusByID
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateOrderStatusByID
func (mmUpdateOrderStatusByID *mOrderMockUpdateOrderStatusByID) Inspect(f func(ctx context.Context, id string, acc float64, status mm_order.Status)) *mOrderMockUpdateOrderStatusByID {
	if mmUpdateOrderStatusByID.mock.inspectFuncUpdateOrderStatusByID != nil {
		mmUpdateOrderStatusByID.mock.t.Fatalf("Inspect function is already set for OrderMock.UpdateOrderStatusByID")
	}

	mmUpdateOrderStatusByID.mock.inspectFuncUpdateOrderStatusByID = f

	return mmUpdateOrderStatusByID
}

// Return sets up results that will be returned by Repository.UpdateOrderStatusByID
func (mmUpdateOrderStatusByID *mOrderMockUpdateOrderStatusByID) Return(err error) *OrderMock {
	if mmUpdateOrderStatusByID.mock.funcUpdateOrderStatusByID != nil {
		mmUpdateOrderStatusByID.mock.t.Fatalf("OrderMock.UpdateOrderStatusByID mock is already set by Set")
	}

	if mmUpdateOrderStatusByID.defaultExpectation == nil {
		mmUpdateOrderStatusByID.defaultExpectation = &OrderMockUpdateOrderStatusByIDExpectation{mock: mmUpdateOrderStatusByID.mock}
	}
	mmUpdateOrderStatusByID.defaultExpectation.results = &OrderMockUpdateOrderStatusByIDResults{err}
	return mmUpdateOrderStatusByID.mock
}

// Set uses given function f to mock the Repository.UpdateOrderStatusByID method
func (mmUpdateOrderStatusByID *mOrderMockUpdateOrderStatusByID) Set(f func(ctx context.Context, id string, acc float64, status mm_order.Status) (err error)) *OrderMock {
	if mmUpdateOrderStatusByID.defaultExpectation != nil {
		mmUpdateOrderStatusByID.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateOrderStatusByID method")
	}

	if len(mmUpdateOrderStatusByID.expectations) > 0 {
		mmUpdateOrderStatusByID.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateOrderStatusByID method")
	}

	mmUpdateOrderStatusByID.mock.funcUpdateOrderStatusByID = f
	return mmUpdateOrderStatusByID.mock
}

// When sets expectation for the Repository.UpdateOrderStatusByID which will trigger the result defined by the following
// Then helper
func (mmUpdateOrderStatusByID *mOrderMockUpdateOrderStatusByID) When(ctx context.Context, id string, acc float64, status mm_order.Status) *OrderMockUpdateOrderStatusByIDExpectation {
	if mmUpdateOrderStatusByID.mock.funcUpdateOrderStatusByID != nil {
		mmUpdateOrderStatusByID.mock.t.Fatalf("OrderMock.UpdateOrderStatusByID mock is already set by Set")
	}

	expectation := &OrderMockUpdateOrderStatusByIDExpectation{
		mock:   mmUpdateOrderStatusByID.mock,
		params: &OrderMockUpdateOrderStatusByIDParams{ctx, id, acc, status},
	}
	mmUpdateOrderStatusByID.expectations = append(mmUpdateOrderStatusByID.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateOrderStatusByID return parameters for the expectation previously defined by the When method
func (e *OrderMockUpdateOrderStatusByIDExpectation) Then(err error) *OrderMock {
	e.results = &OrderMockUpdateOrderStatusByIDResults{err}
	return e.mock
}

// UpdateOrderStatusByID implements order.Repository
func (mmUpdateOrderStatusByID *OrderMock) UpdateOrderStatusByID(ctx context.Context, id string, acc float64, status mm_order.Status) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrderStatusByID.beforeUpdateOrderStatusByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrderStatusByID.afterUpdateOrderStatusByIDCounter, 1)

	if mmUpdateOrderStatusByID.inspectFuncUpdateOrderStatusByID != nil {
		mmUpdateOrderStatusByID.inspectFuncUpdateOrderStatusByID(ctx, id, acc, status)
	}

	mm_params := &OrderMockUpdateOrderStatusByIDParams{ctx, id, acc, status}

	// Record call args
	mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.mutex.Lock()
	mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.callArgs = append(mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.callArgs, mm_params)
	mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.mutex.Unlock()

	for _, e := range mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.defaultExpectation.params
		mm_got := OrderMockUpdateOrderStatusByIDParams{ctx, id, acc, status}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrderStatusByID.t.Errorf("OrderMock.UpdateOrderStatusByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrderStatusByID.UpdateOrderStatusByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrderStatusByID.t.Fatal("No results are set for the OrderMock.UpdateOrderStatusByID")
		}
		return (*mm_results).err
	}
	if mmUpdateOrderStatusByID.funcUpdateOrderStatusByID != nil {
		return mmUpdateOrderStatusByID.funcUpdateOrderStatusByID(ctx, id, acc, status)
	}
	mmUpdateOrderStatusByID.t.Fatalf("Unexpected call to OrderMock.UpdateOrderStatusByID. %v %v %v %v", ctx, id, acc, status)
	return
}

// UpdateOrderStatusByIDAfterCounter returns a count of finished OrderMock.UpdateOrderStatusByID invocations
func (mmUpdateOrderStatusByID *OrderMock) UpdateOrderStatusByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatusByID.afterUpdateOrderStatusByIDCounter)
}

// UpdateOrderStatusByIDBeforeCounter returns a count of OrderMock.UpdateOrderStatusByID invocations
func (mmUpdateOrderStatusByID *OrderMock) UpdateOrderStatusByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrderStatusByID.beforeUpdateOrderStatusByIDCounter)
}

// Calls returns a list of arguments used in each call to OrderMock.UpdateOrderStatusByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrderStatusByID *mOrderMockUpdateOrderStatusByID) Calls() []*OrderMockUpdateOrderStatusByIDParams {
	mmUpdateOrderStatusByID.mutex.RLock()

	argCopy := make([]*OrderMockUpdateOrderStatusByIDParams, len(mmUpdateOrderStatusByID.callArgs))
	copy(argCopy, mmUpdateOrderStatusByID.callArgs)

	mmUpdateOrderStatusByID.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderStatusByIDDone returns true if the count of the UpdateOrderStatusByID invocations corresponds
// the number of defined expectations
func (m *OrderMock) MinimockUpdateOrderStatusByIDDone() bool {
	for _, e := range m.UpdateOrderStatusByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatusByID != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderStatusByIDInspect logs each unmet expectation
func (m *OrderMock) MinimockUpdateOrderStatusByIDInspect() {
	for _, e := range m.UpdateOrderStatusByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to OrderMock.UpdateOrderStatusByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderStatusByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusByIDCounter) < 1 {
		if m.UpdateOrderStatusByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to OrderMock.UpdateOrderStatusByID")
		} else {
			m.t.Errorf("Expected call to OrderMock.UpdateOrderStatusByID with params: %#v", *m.UpdateOrderStatusByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrderStatusByID != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderStatusByIDCounter) < 1 {
		m.t.Error("Expected call to OrderMock.UpdateOrderStatusByID")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *OrderMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCheckIsOrderExistInspect()

		m.MinimockCreateOrderInspect()

		m.MinimockFindOrderByNumInspect()

		m.MinimockFindOrdersByUserIDInspect()

		m.MinimockStartOrderProcessingInspect()

		m.MinimockUpdateOrderStatusByIDInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *OrderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *OrderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckIsOrderExistDone() &&
		m.MinimockCreateOrderDone() &&
		m.MinimockFindOrderByNumDone() &&
		m.MinimockFindOrdersByUserIDDone() &&
		m.MinimockStartOrderProcessingDone() &&
		m.MinimockUpdateOrderStatusByIDDone()
}
